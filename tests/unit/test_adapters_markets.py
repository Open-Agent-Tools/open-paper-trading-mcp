"""Tests for market adapters (PaperMarketAdapter and OrderImpact)."""

import pytest
from unittest.mock import Mock, MagicMock, patch, AsyncMock
from datetime import datetime, timedelta
from typing import Any, Dict

from app.adapters.markets import (
    PaperMarketAdapter,
    OrderImpact,
)
from app.adapters.base import QuoteAdapter
from app.models.assets import Stock, Option, asset_factory
from app.models.quotes import Quote, OptionQuote
from app.schemas.orders import Order, OrderType, OrderStatus, OrderCondition
from app.services.estimators import MarketEstimator, MidpointEstimator


class TestOrderImpact:
    """Test OrderImpact functionality."""

    def test_order_impact_initialization(self):
        """Test OrderImpact initialization."""
        order = Order(
            symbol="AAPL",
            order_type=OrderType.BUY,
            condition=OrderCondition.MARKET,
            quantity=100
        )
        
        impact = OrderImpact(order, 150.0)
        
        assert impact.order is order
        assert impact.current_price == 150.0
        assert impact.executed_price == 150.0
        assert impact.slippage == 0.0
        assert impact.commission == 0.0
        assert impact.total_cost == 0.0
        assert impact.impact_percentage == 0.0

    def test_calculate_impact_market_buy_order(self):
        """Test impact calculation for market buy order."""
        order = Order(
            symbol="AAPL",
            order_type=OrderType.BUY,
            condition=OrderCondition.MARKET,
            quantity=100
        )\n        \n        impact = OrderImpact(order, 150.0)\n        result = impact.calculate_impact(slippage_bps=10.0, commission_per_share=0.01)\n        \n        # Market buy should have positive slippage (higher price)\n        assert impact.executed_price > 150.0\n        assert impact.executed_price == 150.0 * 1.001  # 10bps = 0.1%\n        assert impact.slippage > 0.0\n        assert impact.commission == 1.0  # 100 shares * $0.01\n        assert impact.total_cost > 0.0\n        assert impact.impact_percentage > 0.0\n        \n        # Verify returned dictionary\n        assert result[\"executed_price\"] == impact.executed_price\n        assert result[\"slippage\"] == impact.slippage\n        assert result[\"commission\"] == impact.commission\n        assert result[\"total_cost\"] == impact.total_cost\n        assert result[\"impact_percentage\"] == impact.impact_percentage\n\n    def test_calculate_impact_market_sell_order(self):\n        \"\"\"Test impact calculation for market sell order.\"\"\"\n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.SELL,\n            condition=OrderCondition.MARKET,\n            quantity=100\n        )\n        \n        impact = OrderImpact(order, 150.0)\n        result = impact.calculate_impact(slippage_bps=10.0, commission_per_share=0.01)\n        \n        # Market sell should have negative slippage (lower price)\n        assert impact.executed_price < 150.0\n        assert impact.executed_price == 150.0 / 1.001  # 10bps slippage\n        assert impact.slippage > 0.0  # Absolute value\n        assert impact.commission == 1.0\n        assert impact.total_cost > 0.0  # Net proceeds after commission\n        assert impact.impact_percentage > 0.0\n\n    def test_calculate_impact_limit_order(self):\n        \"\"\"Test impact calculation for limit order.\"\"\"\n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=149.50  # Limit price\n        )\n        \n        impact = OrderImpact(order, 150.0)\n        result = impact.calculate_impact(commission_per_share=0.01)\n        \n        # Limit order should execute at limit price\n        assert impact.executed_price == 149.50\n        assert impact.slippage == 50.0  # |149.50 - 150.0| * 100\n        assert impact.commission == 1.0\n        assert impact.total_cost == 14951.0  # (149.50 * 100) + 1.0\n\n    def test_calculate_impact_limit_order_no_price(self):\n        \"\"\"Test impact calculation for limit order with no price set.\"\"\"\n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=None  # No limit price set\n        )\n        \n        impact = OrderImpact(order, 150.0)\n        result = impact.calculate_impact()\n        \n        # Should default to current price\n        assert impact.executed_price == 150.0\n\n    def test_calculate_impact_option_orders(self):\n        \"\"\"Test impact calculation for option orders.\"\"\"\n        # Test BTO (Buy to Open)\n        bto_order = Order(\n            symbol=\"AAPL170324C00150000\",\n            order_type=OrderType.BTO,\n            condition=OrderCondition.MARKET,\n            quantity=10\n        )\n        \n        impact = OrderImpact(bto_order, 5.50)\n        result = impact.calculate_impact(slippage_bps=20.0, commission_per_share=0.02)\n        \n        assert impact.executed_price > 5.50  # Buy order has positive slippage\n        assert impact.commission == 0.20  # 10 contracts * $0.02\n        \n        # Test BTC (Buy to Close)\n        btc_order = Order(\n            symbol=\"AAPL170324C00150000\",\n            order_type=OrderType.BTC,\n            condition=OrderCondition.MARKET,\n            quantity=10\n        )\n        \n        impact2 = OrderImpact(btc_order, 5.50)\n        result2 = impact2.calculate_impact(slippage_bps=20.0, commission_per_share=0.02)\n        \n        assert impact2.executed_price > 5.50  # BTC is also a buy\n\n    def test_calculate_impact_custom_parameters(self):\n        \"\"\"Test impact calculation with custom slippage and commission.\"\"\"\n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=1000  # Large order\n        )\n        \n        impact = OrderImpact(order, 100.0)\n        result = impact.calculate_impact(\n            slippage_bps=50.0,  # Higher slippage\n            commission_per_share=0.005  # Lower commission\n        )\n        \n        expected_executed_price = 100.0 * 1.005  # 50bps = 0.5%\n        assert impact.executed_price == expected_executed_price\n        assert impact.commission == 5.0  # 1000 * $0.005\n        \n        # Impact percentage should be calculated correctly\n        order_value = 100.0 * 1000  # 100,000\n        expected_impact_pct = ((impact.slippage + impact.commission) / order_value) * 100\n        assert abs(impact.impact_percentage - expected_impact_pct) < 0.001\n\n    def test_calculate_impact_zero_quantity(self):\n        \"\"\"Test impact calculation with zero quantity.\"\"\"\n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=0\n        )\n        \n        impact = OrderImpact(order, 150.0)\n        result = impact.calculate_impact()\n        \n        assert impact.slippage == 0.0\n        assert impact.commission == 0.0\n        assert impact.total_cost == 0.0\n        assert impact.impact_percentage == 0.0  # Avoid division by zero\n\n\nclass MockQuoteAdapter(QuoteAdapter):\n    \"\"\"Mock quote adapter for testing.\"\"\"\n\n    def __init__(self):\n        self.quotes = {}\n        self.market_open = True\n\n    async def get_quote(self, asset):\n        return self.quotes.get(asset.symbol)\n\n    async def get_quotes(self, assets):\n        results = {}\n        for asset in assets:\n            quote = self.quotes.get(asset.symbol)\n            if quote:\n                results[asset] = quote\n        return results\n\n    async def get_chain(self, underlying, expiration_date=None):\n        return []\n\n    async def get_options_chain(self, underlying, expiration_date=None):\n        return None\n\n    async def is_market_open(self):\n        return self.market_open\n\n    async def get_market_hours(self):\n        return {\"open\": \"09:30\", \"close\": \"16:00\"}\n\n    def get_sample_data_info(self):\n        return {\"test\": \"data\"}\n\n    def get_expiration_dates(self, underlying):\n        return []\n\n    def get_test_scenarios(self):\n        return {}\n\n    def set_date(self, date):\n        pass\n\n    def get_available_symbols(self):\n        return []\n\n\nclass TestPaperMarketAdapter:\n    \"\"\"Test PaperMarketAdapter functionality.\"\"\"\n\n    @pytest.fixture\n    def quote_adapter(self):\n        \"\"\"Create mock quote adapter.\"\"\"\n        return MockQuoteAdapter()\n\n    @pytest.fixture\n    def adapter(self, quote_adapter):\n        \"\"\"Create paper market adapter.\"\"\"\n        return PaperMarketAdapter(quote_adapter)\n\n    def test_adapter_initialization(self, quote_adapter):\n        \"\"\"Test adapter initialization.\"\"\"\n        adapter = PaperMarketAdapter(quote_adapter)\n        \n        assert adapter.quote_adapter is quote_adapter\n        assert len(adapter.pending_orders) == 0\n        assert len(adapter.filled_orders) == 0\n        assert isinstance(adapter.midpoint_estimator, MidpointEstimator)\n        assert isinstance(adapter.market_estimator, MarketEstimator)\n\n    @pytest.mark.asyncio\n    async def test_submit_order_generates_id(self, adapter):\n        \"\"\"Test that submit_order generates an ID if none exists.\"\"\"\n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=150.0\n        )\n        \n        submitted = await adapter.submit_order(order)\n        \n        assert submitted.id is not None\n        assert len(submitted.id) == 8  # Short UUID\n        assert submitted.status == OrderStatus.PENDING\n        assert isinstance(submitted.created_at, datetime)\n        assert len(adapter.pending_orders) == 1\n        assert adapter.pending_orders[0] is submitted\n\n    @pytest.mark.asyncio\n    async def test_submit_order_preserves_existing_id(self, adapter):\n        \"\"\"Test that submit_order preserves existing order ID.\"\"\"\n        order = Order(\n            id=\"existing-id\",\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=150.0\n        )\n        \n        submitted = await adapter.submit_order(order)\n        \n        assert submitted.id == \"existing-id\"\n        assert submitted.status == OrderStatus.PENDING\n\n    @pytest.mark.asyncio\n    async def test_submit_market_order_immediate_fill_attempt(self, adapter, quote_adapter):\n        \"\"\"Test that market orders attempt immediate fill.\"\"\"\n        # Setup quote for AAPL\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        # Mock asset factory\n        with patch('app.models.assets.asset_factory', return_value=stock):\n            order = Order(\n                symbol=\"AAPL\",\n                order_type=OrderType.BUY,\n                condition=OrderCondition.MARKET,\n                quantity=100\n            )\n            \n            submitted = await adapter.submit_order(order)\n        \n        # Market order should be filled immediately\n        assert submitted.status == OrderStatus.FILLED\n        assert submitted.filled_at is not None\n        assert len(adapter.pending_orders) == 0  # No longer pending\n        assert len(adapter.filled_orders) == 1\n\n    @pytest.mark.asyncio\n    async def test_submit_limit_order_remains_pending(self, adapter, quote_adapter):\n        \"\"\"Test that limit orders remain pending until conditions are met.\"\"\"\n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=149.0  # Below market\n        )\n        \n        submitted = await adapter.submit_order(order)\n        \n        # Limit order should remain pending\n        assert submitted.status == OrderStatus.PENDING\n        assert submitted.filled_at is None\n        assert len(adapter.pending_orders) == 1\n        assert len(adapter.filled_orders) == 0\n\n    def test_cancel_order_success(self, adapter):\n        \"\"\"Test successful order cancellation.\"\"\"\n        # Add a pending order\n        order = Order(\n            id=\"cancel-me\",\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=149.0,\n            status=OrderStatus.PENDING\n        )\n        adapter.pending_orders.append(order)\n        \n        result = adapter.cancel_order(\"cancel-me\")\n        \n        assert result is True\n        assert order.status == OrderStatus.CANCELLED\n        assert len(adapter.pending_orders) == 0\n\n    def test_cancel_order_not_found(self, adapter):\n        \"\"\"Test cancellation of non-existent order.\"\"\"\n        result = adapter.cancel_order(\"nonexistent-id\")\n        assert result is False\n\n    def test_cancel_order_multiple_orders(self, adapter):\n        \"\"\"Test cancelling specific order when multiple exist.\"\"\"\n        # Add multiple pending orders\n        orders = [\n            Order(id=\"order1\", symbol=\"AAPL\", order_type=OrderType.BUY, condition=OrderCondition.LIMIT, quantity=100, price=149.0, status=OrderStatus.PENDING),\n            Order(id=\"order2\", symbol=\"GOOGL\", order_type=OrderType.SELL, condition=OrderCondition.LIMIT, quantity=50, price=2501.0, status=OrderStatus.PENDING),\n            Order(id=\"order3\", symbol=\"MSFT\", order_type=OrderType.BUY, condition=OrderCondition.LIMIT, quantity=75, price=299.0, status=OrderStatus.PENDING)\n        ]\n        adapter.pending_orders.extend(orders)\n        \n        # Cancel middle order\n        result = adapter.cancel_order(\"order2\")\n        \n        assert result is True\n        assert orders[1].status == OrderStatus.CANCELLED\n        assert len(adapter.pending_orders) == 2\n        assert \"order1\" in [o.id for o in adapter.pending_orders]\n        assert \"order3\" in [o.id for o in adapter.pending_orders]\n\n    def test_get_pending_orders(self, adapter):\n        \"\"\"Test getting pending orders.\"\"\"\n        # Add some orders\n        orders = [\n            Order(id=\"order1\", symbol=\"AAPL\", order_type=OrderType.BUY, condition=OrderCondition.LIMIT, quantity=100, price=149.0, status=OrderStatus.PENDING),\n            Order(id=\"order2\", symbol=\"GOOGL\", order_type=OrderType.SELL, condition=OrderCondition.LIMIT, quantity=50, price=2501.0, status=OrderStatus.PENDING)\n        ]\n        adapter.pending_orders.extend(orders)\n        \n        pending = adapter.get_pending_orders()\n        \n        assert len(pending) == 2\n        assert pending[0].id == \"order1\"\n        assert pending[1].id == \"order2\"\n        \n        # Verify it returns a copy\n        pending.clear()\n        assert len(adapter.get_pending_orders()) == 2\n\n    def test_get_pending_orders_with_account_filter(self, adapter):\n        \"\"\"Test getting pending orders with account filter (placeholder).\"\"\"\n        # Add some orders\n        order = Order(id=\"order1\", symbol=\"AAPL\", order_type=OrderType.BUY, condition=OrderCondition.LIMIT, quantity=100, price=149.0, status=OrderStatus.PENDING)\n        adapter.pending_orders.append(order)\n        \n        # Note: Current implementation ignores account_id filter\n        pending = adapter.get_pending_orders(account_id=\"test-account\")\n        \n        assert len(pending) == 1\n        assert pending[0].id == \"order1\"\n\n    @pytest.mark.asyncio\n    async def test_simulate_order_success(self, adapter, quote_adapter):\n        \"\"\"Test successful order simulation.\"\"\"\n        # Setup quote\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=100\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            result = await adapter.simulate_order(order)\n        \n        assert result[\"success\"] is True\n        assert result[\"would_fill\"] is True\n        assert \"current_price\" in result\n        assert \"impact\" in result\n        assert \"quote\" in result\n        assert result[\"quote\"] is quote\n\n    @pytest.mark.asyncio\n    async def test_simulate_order_invalid_symbol(self, adapter):\n        \"\"\"Test order simulation with invalid symbol.\"\"\"\n        order = Order(\n            symbol=\"INVALID\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=100\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=None):\n            result = await adapter.simulate_order(order)\n        \n        assert result[\"success\"] is False\n        assert result[\"reason\"] == \"Invalid symbol\"\n        assert result[\"impact\"] is None\n\n    @pytest.mark.asyncio\n    async def test_simulate_order_no_quote(self, adapter, quote_adapter):\n        \"\"\"Test order simulation with no quote available.\"\"\"\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        # No quote in quote_adapter.quotes\n        \n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=100\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            result = await adapter.simulate_order(order)\n        \n        assert result[\"success\"] is False\n        assert result[\"reason\"] == \"No quote available\"\n        assert result[\"impact\"] is None\n\n    @pytest.mark.asyncio\n    async def test_simulate_limit_order_would_not_fill(self, adapter, quote_adapter):\n        \"\"\"Test simulating limit order that wouldn't fill.\"\"\"\n        # Setup quote\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        # Limit buy order above ask price (would fill)\n        buy_order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=150.10  # Above ask\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            result = await adapter.simulate_order(buy_order)\n        \n        assert result[\"success\"] is True\n        assert result[\"would_fill\"] is True\n        \n        # Limit buy order below ask price (wouldn't fill)\n        buy_order_low = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=150.00  # Below ask\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            result = await adapter.simulate_order(buy_order_low)\n        \n        assert result[\"success\"] is True\n        assert result[\"would_fill\"] is False\n\n    @pytest.mark.asyncio\n    async def test_process_pending_orders(self, adapter, quote_adapter):\n        \"\"\"Test processing pending orders.\"\"\"\n        # Setup quotes\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        # Add mixed pending orders\n        market_order = Order(\n            id=\"market1\",\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=100,\n            status=OrderStatus.PENDING\n        )\n        \n        limit_order_fill = Order(\n            id=\"limit1\",\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=150.10,  # Above ask, should fill\n            status=OrderStatus.PENDING\n        )\n        \n        limit_order_no_fill = Order(\n            id=\"limit2\",\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=149.00,  # Below ask, won't fill\n            status=OrderStatus.PENDING\n        )\n        \n        adapter.pending_orders.extend([market_order, limit_order_fill, limit_order_no_fill])\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter.process_pending_orders()\n        \n        # Should have filled 2 orders\n        assert len(filled) == 2\n        filled_ids = [o.id for o in filled]\n        assert \"market1\" in filled_ids\n        assert \"limit1\" in filled_ids\n        \n        # One order should remain pending\n        assert len(adapter.pending_orders) == 1\n        assert adapter.pending_orders[0].id == \"limit2\"\n        \n        # Filled orders should have correct status\n        for order in filled:\n            assert order.status == OrderStatus.FILLED\n            assert order.filled_at is not None\n\n    @pytest.mark.asyncio\n    async def test_try_fill_order_market_buy(self, adapter, quote_adapter):\n        \"\"\"Test filling market buy order.\"\"\"\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=100,\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(order)\n        \n        assert filled is True\n        assert order.status == OrderStatus.FILLED\n        assert order.filled_at is not None\n        assert len(adapter.filled_orders) == 1\n\n    @pytest.mark.asyncio\n    async def test_try_fill_order_market_sell(self, adapter, quote_adapter):\n        \"\"\"Test filling market sell order.\"\"\"\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.SELL,\n            condition=OrderCondition.MARKET,\n            quantity=100,\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(order)\n        \n        assert filled is True\n        assert order.status == OrderStatus.FILLED\n\n    @pytest.mark.asyncio\n    async def test_try_fill_order_limit_conditions(self, adapter, quote_adapter):\n        \"\"\"Test limit order fill conditions.\"\"\"\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        # Test buy limit at/above ask (should fill)\n        buy_order_fill = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=150.05,  # At ask\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(buy_order_fill)\n        assert filled is True\n        \n        # Test buy limit below ask (shouldn't fill)\n        buy_order_no_fill = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=150.00,  # Below ask\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(buy_order_no_fill)\n        assert filled is False\n        \n        # Test sell limit at/below bid (should fill)\n        sell_order_fill = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.SELL,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=149.95,  # At bid\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(sell_order_fill)\n        assert filled is True\n        \n        # Test sell limit above bid (shouldn't fill)\n        sell_order_no_fill = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.SELL,\n            condition=OrderCondition.LIMIT,\n            quantity=100,\n            price=150.00,  # Above bid\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(sell_order_no_fill)\n        assert filled is False\n\n    @pytest.mark.asyncio\n    async def test_try_fill_order_stop_conditions(self, adapter, quote_adapter):\n        \"\"\"Test stop order fill conditions.\"\"\"\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        # Test buy stop above current price (should trigger)\n        buy_stop_trigger = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.STOP,\n            quantity=100,\n            price=149.0,  # Below current price\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(buy_stop_trigger)\n        assert filled is True\n        \n        # Test sell stop below current price (should trigger)\n        sell_stop_trigger = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.SELL,\n            condition=OrderCondition.STOP,\n            quantity=100,\n            price=151.0,  # Above current price\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(sell_stop_trigger)\n        assert filled is True\n\n    @pytest.mark.asyncio\n    async def test_try_fill_order_no_asset(self, adapter):\n        \"\"\"Test trying to fill order with invalid asset.\"\"\"\n        order = Order(\n            symbol=\"INVALID\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=100,\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=None):\n            filled = await adapter._try_fill_order(order)\n        \n        assert filled is False\n        assert order.status == OrderStatus.PENDING  # Should remain unchanged\n\n    @pytest.mark.asyncio\n    async def test_try_fill_order_no_quote(self, adapter, quote_adapter):\n        \"\"\"Test trying to fill order with no quote available.\"\"\"\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        # No quote in quote_adapter\n        \n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=100,\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(order)\n        \n        assert filled is False\n        assert order.status == OrderStatus.PENDING\n\n    @pytest.mark.asyncio\n    async def test_try_fill_order_zero_price(self, adapter, quote_adapter):\n        \"\"\"Test trying to fill order when calculated fill price is zero.\"\"\"\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=0.0,  # Zero price\n            bid=0.0,\n            ask=0.0,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        order = Order(\n            symbol=\"AAPL\",\n            order_type=OrderType.BUY,\n            condition=OrderCondition.MARKET,\n            quantity=100,\n            status=OrderStatus.PENDING\n        )\n        \n        with patch('app.models.assets.asset_factory', return_value=stock):\n            filled = await adapter._try_fill_order(order)\n        \n        assert filled is False  # Zero price shouldn't fill\n        assert order.status == OrderStatus.PENDING\n\n    def test_order_processing_integration(self, adapter, quote_adapter):\n        \"\"\"Test complete order processing workflow.\"\"\"\n        # This test demonstrates a complete workflow\n        stock = Stock(symbol=\"AAPL\", name=\"Apple Inc.\")\n        quote = Quote(\n            asset=stock,\n            quote_date=datetime.now(),\n            price=150.0,\n            bid=149.95,\n            ask=150.05,\n            bid_size=100,\n            ask_size=100,\n            volume=1000000\n        )\n        quote_adapter.quotes[\"AAPL\"] = quote\n        \n        # Simulate a trading session\n        with patch('app.models.assets.asset_factory', return_value=stock):\n            # 1. Submit various orders\n            market_buy = Order(symbol=\"AAPL\", order_type=OrderType.BUY, condition=OrderCondition.MARKET, quantity=100)\n            limit_sell = Order(symbol=\"AAPL\", order_type=OrderType.SELL, condition=OrderCondition.LIMIT, quantity=50, price=149.90)\n            stop_buy = Order(symbol=\"AAPL\", order_type=OrderType.BUY, condition=OrderCondition.STOP, quantity=75, price=149.00)\n            \n            # Submit orders asynchronously\n            import asyncio\n            \n            async def submit_orders():\n                await adapter.submit_order(market_buy)\n                await adapter.submit_order(limit_sell)\n                await adapter.submit_order(stop_buy)\n                \n                # Check states\n                assert market_buy.status == OrderStatus.FILLED  # Market order filled immediately\n                assert limit_sell.status == OrderStatus.PENDING  # Limit sell below bid, pending\n                assert stop_buy.status == OrderStatus.FILLED  # Stop triggered\n                \n                # Process any remaining pending orders\n                filled = await adapter.process_pending_orders()\n                \n                return filled\n            \n            filled_orders = asyncio.run(submit_orders())\n            \n            # Verify final state\n            assert len(adapter.filled_orders) >= 2  # At least market and stop orders filled\n            assert all(order.filled_at is not None for order in adapter.filled_orders)\n            assert all(order.status == OrderStatus.FILLED for order in adapter.filled_orders)"